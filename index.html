<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="css/L.Control.Layers.Tree.css">
        <link rel="stylesheet" href="css/qgis2web.css">
        <link rel="stylesheet" href="css/fontawesome-all.min.css">
        <link rel="stylesheet" href="css/leaflet.photon.css">
        <link rel="stylesheet" href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css">
        <style>
        html, body {
            background: #000;
            color: #fff;
            margin: 0;
            width: 100%;
            height: 100%;
        }
        #map {
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        .map-top-ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: min(92vw, 460px);
            min-width: min(320px, 92vw);
            max-width: min(92vw, 460px);
            background: rgba(0, 0, 0, 0.72);
            color: #fff;
            border: 1px solid #2f2f2f;
            border-radius: 10px;
            padding: 10px 12px;
            box-sizing: border-box;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        }
        .map-labels-title {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        .map-labels-subtitle {
            font-size: 13px;
            color: #efefef;
            line-height: 1.5;
        }
        .map-labels-list {
            margin: 6px 0 6px 18px;
            padding: 0;
        }
        .map-labels-list li {
            margin: 2px 0;
        }
        .map-score-legend {
            margin-top: 8px;
        }
        .map-score-legend-bar {
            position: relative;
            overflow: hidden;
            height: 10px;
            border-radius: 999px;
            border: 1px solid #444;
            background: linear-gradient(90deg, #d73027 0%, #f46d43 25%, #fee08b 50%, #66bd63 75%, #1a9850 100%);
        }
        .map-score-legend-bar::after {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                90deg,
                rgba(0, 0, 0, 0.22) 0 1px,
                transparent 1px 20%
            );
            pointer-events: none;
        }
        .map-score-legend-scales {
            position: relative;
            height: 16px;
            margin-top: 4px;
        }
        .map-score-legend-scale {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #ddd;
            line-height: 1;
        }
        .map-score-legend-scale.major span {
            font-size: 12px;
            font-weight: 700;
            color: #f0f0f0;
        }
        .map-score-legend-scale.minor {
            font-size: 8px;
            color: #a8a8a8;
            left: 0;
            right: 0;
        }
        .map-score-legend-scale.minor span {
            position: absolute;
            transform: translateX(-50%);
            text-align: center;
        }
        .map-score-legend-scale.minor .p10 { left: 10%; }
        .map-score-legend-scale.minor .p20 { left: 20%; }
        .map-score-legend-scale.minor .p30 { left: 30%; }
        .map-score-legend-scale.minor .p40 { left: 40%; }
        .map-score-legend-scale.minor .p60 { left: 60%; }
        .map-score-legend-scale.minor .p70 { left: 70%; }
        .map-score-legend-scale.minor .p80 { left: 80%; }
        .map-score-legend-scale.minor .p90 { left: 90%; }
        .map-score-legend-notes {
            margin-top: 4px;
            display: flex;
            justify-content: space-between;
            gap: 8px;
            font-size: 11px;
            color: #d7d7d7;
        }
        .map-dot-key {
            margin: 8px 0 2px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 12px;
        }
        .map-dot-key-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .map-dot-sample {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fbc07d;
            border: 1.6px solid #232323;
            box-sizing: border-box;
            flex: 0 0 14px;
            position: relative;
        }
        .map-dot-sample-dark::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 2px;
            bottom: 2px;
            width: 1.8px;
            transform: translateX(-50%);
            background: #000;
            border-radius: 1px;
        }
        .leaflet-tooltip.mankkaa-dark-line-tooltip {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #000;
            font-size: 13px;
            font-weight: 900;
            line-height: 1;
            padding: 0;
            margin: 0;
            text-align: center;
            pointer-events: none;
        }
        .leaflet-tooltip.mankkaa-dark-line-tooltip::before {
            display: none !important;
        }
        .map-top-controls {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        .map-top-controls .map-ui-row {
            margin-top: 0;
            width: 100%;
        }
        .map-top-controls .map-ui-row button {
            width: 100%;
            min-width: 0;
        }
        .map-top-controls .map-feedback-block {
            margin-top: 0;
            border-top: 0;
            padding-top: 0;
        }
        #paletteSliderUi {
            margin-top: 8px;
        }
        .palette-slider-ui {
            position: static;
            z-index: auto;
            background: transparent;
            border: 0;
            border-radius: 0;
            padding: 0;
            color: #fff;
            font-family: inherit;
            width: 100%;
        }
        .palette-toggle-btn {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px 8px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
            margin-bottom: 6px;
        }
        .palette-toggle-btn:hover {
            background: #171717;
        }
        .palette-slider-body {
            max-height: min(74vh, 720px);
            opacity: 1;
            overflow-y: auto;
            overflow-x: hidden;
            transition: max-height 0.22s ease, opacity 0.2s ease;
        }
        .palette-slider-ui.collapsed .palette-slider-body {
            max-height: 0;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .palette-slider-current {
            font-size: 12px;
            color: #d0e7ff;
            margin-bottom: 6px;
            min-height: 16px;
        }
        .palette-slider-inner {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .palette-slider-track {
            width: 22px;
            height: 130px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #scorePaletteSlider {
            width: 130px;
            height: 20px;
            transform: rotate(90deg);
            transform-origin: center;
            margin: 0;
            accent-color: #9ecbff;
            cursor: pointer;
        }
        .palette-slider-ticks {
            height: 130px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 11px;
            color: #bdbdbd;
            line-height: 1;
            user-select: none;
        }
        .palette-slider-tick {
            cursor: pointer;
            transition: color 0.15s ease;
        }
        .palette-slider-tick.active {
            color: #fff;
            font-weight: 700;
        }
        .basemap-mode-row {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .basemap-mode-row label {
            font-size: 11px;
            color: #d6d6d6;
        }
        .basemap-mode-row select {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px 6px;
            font-size: 12px;
            width: 100%;
        }
        .layer-toggle-row {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .layer-toggle-row-title {
            font-size: 11px;
            color: #d6d6d6;
        }
        .layer-toggle-row-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        .layer-toggle-item {
            display: flex;
            align-items: center;
            gap: 7px;
            font-size: 12px;
            color: #fff;
            cursor: pointer;
            user-select: none;
        }
        .layer-toggle-item input[type="checkbox"] {
            margin: 0;
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        #mapillaryDataToggle {
            accent-color: #ffd84d;
        }
        #groupPhotosToggle {
            accent-color: #9ecbff;
        }
        .map-feedback-block {
            margin-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.16);
            padding-top: 10px;
        }
        .map-feedback-block.hidden {
            display: none;
        }
        .map-feedback-toggle-btn {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px 8px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
        }
        .map-feedback-toggle-btn:hover {
            background: #171717;
        }
        .map-feedback-form {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
        }
        .map-feedback-form.hidden {
            display: none;
        }
        .map-feedback-form label {
            color: #d6d6d6;
            font-size: 11px;
        }
        .map-feedback-rating-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .map-feedback-rating-row input[type="range"] {
            flex: 1 1 auto;
            accent-color: #8e8e8e;
        }
        .map-feedback-rating-value {
            width: 22px;
            text-align: center;
            color: #fff;
            font-weight: 700;
        }
        .map-feedback-form textarea {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 6px 8px;
            min-height: 72px;
            resize: vertical;
            font-size: 12px;
            font-family: inherit;
        }
        .map-feedback-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .map-feedback-actions button {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px 8px;
            font-size: 12px;
            cursor: pointer;
        }
        .map-feedback-actions button:hover {
            background: #171717;
        }
        .map-feedback-status {
            min-height: 16px;
            color: #d2d2d2;
            font-size: 11px;
        }
        .map-feedback-status.error {
            color: #ff9b9b;
        }
        .map-feedback-honeypot {
            display: none;
        }
        .map-ui-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 12px;
        }
        .map-ui-row select {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px 6px;
            font-size: 12px;
        }
        .map-ui-row button {
            background: #0f0f0f;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px 8px;
            min-width: 96px;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
        }
        .map-ui-row button:hover {
            background: #171717;
        }
        .map-labels-block.hidden {
            display: none;
        }
        .map-bottom-ui {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            max-width: min(92vw, 520px);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        }
        .credits-btn {
            background: rgba(0, 0, 0, 0.76);
            color: #fff;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        .credits-btn:hover {
            background: rgba(20, 20, 20, 0.86);
        }
        .credits-panel {
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.82);
            color: #ddd;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 11px;
            line-height: 1.4;
        }
        .credits-panel.hidden {
            display: none;
        }
        .credits-panel a {
            color: #9ecbff;
        }
        .map-compass {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 78px;
            height: 78px;
            z-index: 1000;
            border-radius: 50%;
            border: 1px solid #3a3a3a;
            background: rgba(0, 0, 0, 0.72);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        .map-compass.hidden {
            display: none;
        }
        .map-shadow-clock {
            position: static;
            margin-top: 8px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.78);
            color: #fff;
            border: 1px solid #3a3a3a;
            border-radius: 10px;
            padding: 8px 10px;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            pointer-events: auto;
        }
        .map-shadow-clock.hidden {
            display: none;
        }
        .map-shadow-clock-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 11px;
            color: #d8d8d8;
        }
        .map-shadow-now-btn {
            background: #171717;
            color: #fff;
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            padding: 2px 7px;
            font-size: 11px;
            white-space: nowrap;
            flex: 0 0 auto;
            cursor: pointer;
        }
        .map-shadow-now-btn:hover {
            background: #222;
        }
        .map-shadow-time {
            font-size: 21px;
            font-weight: 700;
            line-height: 1.1;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.04em;
            margin-bottom: 6px;
        }
        #shadowTimeSlider {
            width: 100%;
            box-sizing: border-box;
            accent-color: #ffd84d;
            cursor: pointer;
        }
        .map-shadow-week-wrap {
            margin-top: 6px;
        }
        .map-shadow-week-btn {
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            background: #171717;
            color: #fff;
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            padding: 5px 8px;
            font-size: 11px;
            cursor: pointer;
        }
        .map-shadow-week-btn:hover {
            background: #222;
        }
        .map-shadow-week-btn span:last-child {
            flex: 0 0 auto;
            white-space: nowrap;
        }
        .map-shadow-week-panel {
            margin-top: 6px;
            box-sizing: border-box;
            padding: 6px 7px;
            border: 1px solid #3a3a3a;
            border-radius: 7px;
            background: rgba(8, 8, 8, 0.72);
        }
        .map-shadow-week-panel.hidden {
            display: none;
        }
        .map-shadow-week-meta {
            font-size: 11px;
            color: #f0f0f0;
            margin-bottom: 6px;
            font-variant-numeric: tabular-nums;
        }
        #shadowWeekSlider {
            width: 100%;
            box-sizing: border-box;
            accent-color: #ffd84d;
            cursor: pointer;
        }
        .map-shadow-live {
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #f0f0f0;
            user-select: none;
        }
        .map-shadow-live input[type="checkbox"] {
            accent-color: #ffd84d;
            width: 14px;
            height: 14px;
            margin: 0;
            cursor: pointer;
        }
        .map-shadow-note {
            margin-top: 4px;
            font-size: 10px;
            color: #bbbbbb;
        }
        .map-compass-face {
            position: relative;
            width: 62px;
            height: 62px;
            border-radius: 50%;
            border: 1px solid #4a4a4a;
        }
        .map-compass-face::before,
        .map-compass-face::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.16);
        }
        .map-compass-face::before {
            left: 50%;
            top: 7px;
            bottom: 7px;
            width: 1px;
            transform: translateX(-50%);
        }
        .map-compass-face::after {
            top: 50%;
            left: 7px;
            right: 7px;
            height: 1px;
            transform: translateY(-50%);
        }
        .map-compass-dir {
            position: absolute;
            font-size: 10px;
            font-weight: 700;
            color: #d8d8d8;
            line-height: 1;
            transform: translate(-50%, -50%);
        }
        .map-compass-dir.n {
            top: 8px;
            left: 50%;
            color: #fff;
        }
        .map-compass-dir.e {
            top: 50%;
            left: calc(100% - 8px);
        }
        .map-compass-dir.s {
            top: calc(100% - 8px);
            left: 50%;
        }
        .map-compass-dir.w {
            top: 50%;
            left: 8px;
        }
        .map-compass-arrow {
            position: absolute;
            left: 50%;
            top: 18px;
            width: 2px;
            height: 22px;
            background: #f2f2f2;
            transform: translateX(-50%);
            border-radius: 1px;
        }
        .map-compass-arrow::before {
            content: '';
            position: absolute;
            left: 50%;
            top: -6px;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #f2f2f2;
        }
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: #000;
            color: #fff;
        }
        .leaflet-popup {
            max-width: calc(100vw - 20px);
        }
        .leaflet-popup-content-wrapper {
            max-width: min(92vw, 860px);
            overflow: hidden;
            box-sizing: border-box;
            border: 1px solid #222;
        }
        .leaflet-popup-tip-container,
        .leaflet-popup-tip {
            display: none;
        }
        .leaflet-popup-content {
            font-size: clamp(10px, 1.35vw, 14px);
            line-height: 1.35;
            margin: 8px 10px;
            width: min(84vw, 420px);
            max-width: 100%;
            max-height: min(70vh, 640px);
            overflow: auto;
            box-sizing: border-box;
            overflow-wrap: anywhere;
        }
        .leaflet-popup-content table {
            color: #fff;
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;
        }
        .leaflet-popup-content th,
        .leaflet-popup-content td {
            border-bottom: 1px solid #333;
            padding: 4px 6px;
            vertical-align: top;
            word-break: break-word;
            overflow-wrap: anywhere;
        }
        .leaflet-popup-content th {
            text-align: left;
            color: #ddd;
            white-space: normal;
            width: 38%;
        }
        .leaflet-popup-content a {
            color: #9ecbff;
        }
        .popup-photo-thumb {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: min(38vh, 340px);
            object-fit: contain;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: zoom-in;
        }
        .popup-photo-actions {
            margin-top: 6px;
            display: flex;
            justify-content: flex-start;
        }
        .photo-open-btn {
            background: #121212;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
        }
        .photo-open-btn:hover {
            background: #1a1a1a;
        }
        @media (min-width: 1024px) {
            .map-top-ui {
                width: min(78vw, 700px);
                max-width: min(78vw, 700px);
                padding: 12px 14px;
            }
            .map-labels-title {
                font-size: 16px;
            }
            .map-labels-subtitle {
                font-size: 13px;
            }
            .map-ui-row button {
                font-size: 13px;
                min-width: 112px;
                padding: 6px 10px;
            }
            .leaflet-popup-content {
                font-size: clamp(12px, 0.95vw, 15px);
                width: min(56vw, 720px);
                max-width: 100%;
            }
            .popup-photo-thumb {
                max-width: 100%;
                max-height: min(52vh, 560px);
            }
        }
        @media (min-width: 1440px) {
            .map-top-ui {
                width: min(70vw, 860px);
                max-width: min(70vw, 860px);
            }
            .leaflet-popup-content {
                font-size: clamp(13px, 0.85vw, 16px);
                width: min(52vw, 860px);
                max-width: 100%;
            }
            .popup-photo-thumb {
                max-width: 100%;
                max-height: min(58vh, 700px);
            }
        }
        @media (orientation: landscape) and (max-width: 1024px) {
            .leaflet-popup-content {
                width: min(78vw, 760px);
                max-width: 100%;
                max-height: 66vh;
            }
            .popup-photo-thumb {
                max-width: 100%;
                max-height: min(62vh, 420px);
            }
            .map-top-ui {
                width: min(95vw, 760px);
                max-width: min(95vw, 760px);
            }
        }
        .photo-lightbox.hidden {
            display: none;
        }
        .photo-lightbox {
            position: fixed;
            inset: 0;
            z-index: 5000;
            background: rgba(0, 0, 0, 0.96);
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        .photo-lightbox img {
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
            transform-origin: center center;
            transition: transform 0.08s linear;
        }
        .photo-lightbox-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
        }
        .photo-lightbox-controls button {
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
            min-width: 40px;
            cursor: pointer;
        }
        </style>
        <title></title>
    </head>
    <body>
        <div id="map">
            <div class="map-top-ui">
                <div id="mapLabelsBlock" class="map-labels-block hidden">
                    <div class="map-labels-title"><strong>Leppävaara + Kivenlahti + Mankkaa — AI Map (SPT UE 2026)</strong></div>
                    <div class="map-labels-subtitle">
                        Tap a dot to view the AI label, score, and short explanation.<br>
                        Analysis is generated with ChatGPT (GPT-5) for the SPT Urban Experience course (2026).<br><br>
                        Mankkaa lighting comparison (not color-only):
                        <div class="map-dot-key">
                            <div class="map-dot-key-row">
                                <span class="map-dot-sample map-dot-sample-dark" aria-hidden="true"></span>
                                <span>Dark (after sunset) = same rim + black inner line</span>
                            </div>
                            <div class="map-dot-key-row">
                                <span class="map-dot-sample map-dot-sample-light" aria-hidden="true"></span>
                                <span>Light (daylight) = same rim (no inner line)</span>
                            </div>
                        </div>
                        <strong>Note:</strong> GPS can be inaccurate (especially under bridges), so dots may appear slightly shifted.<br>
                        If a dot doesn’t open, try tapping it again.
                    </div>
                    <div class="map-score-legend" aria-label="AI overall score legend">
                        <div id="scoreLegendBar" class="map-score-legend-bar"></div>
                        <div class="map-score-legend-scales">
                            <div class="map-score-legend-scale major">
                                <span>-5</span>
                                <span>0</span>
                                <span>+5</span>
                            </div>
                            <div class="map-score-legend-scale minor">
                                <span class="p10">-4</span>
                                <span class="p20">-3</span>
                                <span class="p30">-2</span>
                                <span class="p40">-1</span>
                                <span class="p60">+1</span>
                                <span class="p70">+2</span>
                                <span class="p80">+3</span>
                                <span class="p90">+4</span>
                            </div>
                        </div>
                        <div class="map-score-legend-notes">
                            <span id="scoreLegendLowLabel">Red = lower score</span>
                            <span id="scoreLegendHighLabel">Green = higher score</span>
                        </div>
                    </div>
                    <div class="map-ui-row">
                        <button id="gotoLeppaBtn" type="button">Leppävaara</button>
                        <button id="gotoKivenlahtiBtn" type="button">Kivenlahti</button>
                        <button id="gotoMankkaaBtn" type="button">Mankkaa</button>
                    </div>
                </div>
                <div class="map-top-controls">
                    <div class="map-ui-row">
                        <button id="labelToggleBtn" type="button">Show labels</button>
                    </div>
                    <div class="map-feedback-block">
                        <button id="feedbackToggleBtn" class="map-feedback-toggle-btn" type="button" aria-expanded="false">
                            ✨ Please give opinion of this AI sentiment - help thesis student :) ✨
                        </button>
                        <form id="feedbackForm" class="map-feedback-form hidden" name="ai_sentiment_poll" method="POST" action="/" data-netlify="true" netlify-honeypot="bot-field">
                            <input type="hidden" name="form-name" value="ai_sentiment_poll">
                            <p class="map-feedback-honeypot">
                                <label>Do not fill this field: <input name="bot-field"></label>
                            </p>
                            <label for="feedbackRating">Rating (0-10)</label>
                            <div class="map-feedback-rating-row">
                                <input id="feedbackRating" name="rating_0_to_10" type="range" min="0" max="10" step="1" value="0">
                                <output id="feedbackRatingValue" class="map-feedback-rating-value" for="feedbackRating">0</output>
                            </div>
                            <label for="feedbackOpinion">Open opinion</label>
                            <textarea id="feedbackOpinion" name="opinion" placeholder="What do you agree/disagree with in the AI sentiment?" maxlength="800" required></textarea>
                            <input id="feedbackMapHash" type="hidden" name="map_hash">
                            <input id="feedbackMapCenterLat" type="hidden" name="map_center_lat">
                            <input id="feedbackMapCenterLon" type="hidden" name="map_center_lon">
                            <input id="feedbackMapZoom" type="hidden" name="map_zoom">
                            <input id="feedbackSelectedPlace" type="hidden" name="selected_place">
                            <input id="feedbackSubmittedAt" type="hidden" name="submitted_at_utc">
                            <input id="feedbackSiteOrigin" type="hidden" name="site_origin">
                            <div class="map-feedback-actions">
                                <button id="feedbackSubmitBtn" type="submit">Send</button>
                            </div>
                            <div id="feedbackStatus" class="map-feedback-status" aria-live="polite"></div>
                        </form>
                    </div>
                    <div id="paletteSliderUi" class="palette-slider-ui" aria-label="Score color mode control">
                        <button id="paletteSliderToggleBtn" class="palette-toggle-btn" type="button" aria-expanded="true">Hide color mode</button>
                        <div id="paletteSliderBody" class="palette-slider-body">
                            <div id="paletteSliderCurrent" class="palette-slider-current">Trichromacy</div>
                            <div class="palette-slider-inner">
                                <div class="palette-slider-track">
                                    <input id="scorePaletteSlider" type="range" min="0" max="3" step="1" value="0" aria-label="Score color mode slider">
                                </div>
                                <div class="palette-slider-ticks">
                                    <span class="palette-slider-tick active" data-mode="normal">Trichromacy</span>
                                    <span class="palette-slider-tick" data-mode="redgreen">Red-Green CVD</span>
                                    <span class="palette-slider-tick" data-mode="blueyellow">Blue-Yellow CVD</span>
                                    <span class="palette-slider-tick" data-mode="mono">Monochrome</span>
                                </div>
                            </div>
                            <div class="basemap-mode-row">
                                <label for="basemapSelect">Basemap</label>
                                <select id="basemapSelect" aria-label="Basemap style">
                                    <option value="positron">Positron (gray)</option>
                                    <option value="osm">OpenStreetMap</option>
                                    <option value="osm3d">OpenStreetMap + 3D buildings</option>
                                    <option value="positron3dgray">Positron (gray) + 3D buildings</option>
                                </select>
                            </div>
                            <div class="basemap-mode-row">
                                <label for="mapillaryViewSelect">Mapillary overlay</label>
                                <select id="mapillaryViewSelect" aria-label="Mapillary overlay style">
                                    <option value="dots">Colored dots</option>
                                    <option value="heat">Road bands</option>
                                </select>
                            </div>
                            <div class="layer-toggle-row" aria-label="Photo and Mapillary layer visibility">
                                <div class="layer-toggle-row-title">Show layers</div>
                                <div class="layer-toggle-row-controls">
                                    <label class="layer-toggle-item" for="groupPhotosToggle">
                                        <input id="groupPhotosToggle" type="checkbox" checked>
                                        <span>Group photos</span>
                                    </label>
                                    <label class="layer-toggle-item" for="mapillaryDataToggle">
                                        <input id="mapillaryDataToggle" type="checkbox" checked>
                                        <span>Mapillary photos</span>
                                    </label>
                                </div>
                            </div>
                            <div id="shadowClockControl" class="map-shadow-clock hidden" aria-hidden="true" aria-label="3D shadow time control">
                                <div class="map-shadow-clock-head">
                                    <span>3D shadow time</span>
                                    <button id="shadowNowBtn" class="map-shadow-now-btn" type="button">Now</button>
                                </div>
                                <div id="shadowTimeLabel" class="map-shadow-time">12:00</div>
                                <input id="shadowTimeSlider" type="range" min="0" max="1439" step="5" value="720" aria-label="Shadow time of day">
                                <div class="map-shadow-week-wrap">
                                    <button id="shadowWeekToggleBtn" class="map-shadow-week-btn" type="button" aria-expanded="false">
                                        <span>Week number</span>
                                        <span id="shadowWeekLabel">W01</span>
                                    </button>
                                    <div id="shadowWeekPanel" class="map-shadow-week-panel hidden" aria-hidden="true">
                                        <div id="shadowWeekMeta" class="map-shadow-week-meta">Week 01</div>
                                        <input id="shadowWeekSlider" type="range" min="1" max="53" step="1" value="1" aria-label="Shadow ISO week number">
                                    </div>
                                </div>
                                <label class="map-shadow-live" for="shadowLiveToggle">
                                    <input id="shadowLiveToggle" type="checkbox">
                                    <span>Live time</span>
                                </label>
                                <div class="map-shadow-note">Local timezone. Drag slider to test different sun/shadow times.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="mapCompass" class="map-compass hidden" aria-hidden="true" aria-label="Compass">
                <div class="map-compass-face">
                    <span class="map-compass-dir n">N</span>
                    <span class="map-compass-dir e">E</span>
                    <span class="map-compass-dir s">S</span>
                    <span class="map-compass-dir w">W</span>
                    <span class="map-compass-arrow" aria-hidden="true"></span>
                </div>
            </div>
            <div class="map-bottom-ui">
                <button id="creditsToggleBtn" class="credits-btn" type="button">Show credits & privacy</button>
                <div id="creditsPanel" class="credits-panel hidden">
                    <strong>Credits &amp; licenses</strong><br>
                    Basemap data: &copy; OpenStreetMap contributors (ODbL).<br>
                    Tiles/styles:<br>
                    OpenFreeMap Positron (gray): &copy; OpenFreeMap, style by OpenMapTiles, data &copy; OpenStreetMap contributors.<br>
                    OpenStreetMap Standard: &copy; OpenStreetMap contributors; tiles served by tile.openstreetmap.org (usage policy applies).<br>
                    3D buildings rendering: OSM Buildings. Building footprints/data: &copy; OpenStreetMap contributors (ODbL).<br>
                    Web map stack: QGIS, qgis2web, Leaflet, MapLibre.<br>
                    <br>
                    <strong>Project / privacy</strong><br>
                    Project: SPT UE Course 2026.<br>
                    Photos and AI labels shown here are course project material. Reuse only with permission from the project owners.<br>
                    If publishing online, sanitize images first (faces/plates/addresses and EXIF location metadata).
                </div>
            </div>
        </div>
        <div id="photoLightbox" class="photo-lightbox hidden" aria-hidden="true">
            <div class="photo-lightbox-controls">
                <button id="photoZoomOutBtn" type="button" aria-label="Zoom out">-</button>
                <button id="photoZoomInBtn" type="button" aria-label="Zoom in">+</button>
                <button id="photoZoomResetBtn" type="button" aria-label="Reset zoom">100%</button>
                <button id="photoCloseBtn" type="button" aria-label="Close image">×</button>
            </div>
            <img id="photoLightboxImg" alt="Fullscreen photo">
        </div>
        <script src="js/qgis2web_expressions.js"></script>
        <script src="js/leaflet.js"></script>
        <script src="js/leaflet-heat.js"></script>
        <script src="js/L.Control.Layers.Tree.min.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="js/leaflet.photon.js"></script>
        <script src="js/OSMBuildings-Leaflet.js"></script>
        <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
        <script src="https://unpkg.com/@maplibre/maplibre-gl-leaflet/leaflet-maplibre-gl.js"></script>
        <script src="data/spt_ai_combined_1.js"></script>
        <script src="data/mapillary_downloaded_points.js"></script>
        <script>
        var map = L.map('map', {
            zoomControl:false, maxZoom:28, minZoom:1
        }).fitBounds([[60.15340833,24.63408333],[60.22122222,24.82517222]]);
        var hash = new L.Hash(map);
        var LEPPA_BOUNDS = [[60.21526667,24.81157222],[60.22122222,24.82517222]];
        var KIVENLAHTI_BOUNDS = [[60.15340833,24.63408333],[60.15463611,24.63730556]];
        var MANKKAA_BOUNDS = [[60.19366389,24.7659758],[60.1967887,24.77082222]];
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');
        var BASEMAP_MODES = {
            positron: 'Positron (gray)',
            osm: 'OpenStreetMap',
            osm3d: 'OpenStreetMap + 3D buildings',
            positron3dgray: 'Positron (gray) + 3D buildings'
        };
        var OSM_BUILDINGS_TILE_URL = 'https://{s}.data.osmbuildings.org/0.2/59fcc2e8/tile/{z}/{x}/{y}.json';
        var OSM_BUILDINGS_MIN_ZOOM = 15;
        var OSM_BUILDINGS_STYLES = {
            osm3d: {
                color: '#d4c7bc',
                roofColor: '#f1ebe7',
                shadows: true
            },
            positron3dgray: {
                color: '#8f8f8f',
                roofColor: '#bdbdbd',
                shadows: true
            }
        };
        var currentBasemapMode = 'positron';
        try {
            var savedBasemapMode = localStorage.getItem('basemapMode');
            if (savedBasemapMode && BASEMAP_MODES[savedBasemapMode]) {
                currentBasemapMode = savedBasemapMode;
            }
        } catch (e) {}
        var baseLayerPositron = L.maplibreGL({
            style: 'https://tiles.openfreemap.org/styles/positron',
            attribution: '&copy; OpenFreeMap, style by OpenMapTiles, data &copy; OpenStreetMap contributors'
        });
        var baseLayerOsm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap contributors'
        });
        var baseLayerOsmBuildings3d = null;
        if (typeof OSMBuildings !== 'undefined') {
            baseLayerOsmBuildings3d = new OSMBuildings();
            // Use explicit https tile endpoint for better browser compatibility.
            baseLayerOsmBuildings3d.load(OSM_BUILDINGS_TILE_URL);
        }
        function is3dBasemapMode(modeKey) {
            return modeKey === 'osm3d' || modeKey === 'positron3dgray';
        }
        function usesOsmBasemap(modeKey) {
            return modeKey === 'osm' || modeKey === 'osm3d';
        }
        function apply3dBuildingStyle(modeKey) {
            if (!baseLayerOsmBuildings3d) return;
            var styleKey = OSM_BUILDINGS_STYLES[modeKey] ? modeKey : 'osm3d';
            baseLayerOsmBuildings3d.style(OSM_BUILDINGS_STYLES[styleKey]);
        }

        function getIsoWeekInfo(dateValue) {
            var d = new Date(dateValue && dateValue.getTime ? dateValue.getTime() : dateValue);
            if (!Number.isFinite(d.getTime())) {
                d = new Date();
            }
            d.setHours(12, 0, 0, 0);
            var weekday = d.getDay();
            weekday = weekday === 0 ? 7 : weekday;
            d.setDate(d.getDate() + 4 - weekday);
            var isoYear = d.getFullYear();
            var jan4 = new Date(isoYear, 0, 4, 12, 0, 0, 0);
            var jan4Weekday = jan4.getDay();
            jan4Weekday = jan4Weekday === 0 ? 7 : jan4Weekday;
            var week1Monday = new Date(jan4);
            week1Monday.setDate(jan4.getDate() - jan4Weekday + 1);
            var week = Math.floor((d - week1Monday) / 604800000) + 1;
            return {
                isoYear: isoYear,
                week: week,
                weekday: weekday
            };
        }

        function getIsoWeeksInYear(isoYear) {
            var y = Number(isoYear);
            if (!Number.isFinite(y)) y = new Date().getFullYear();
            y = Math.round(y);
            return getIsoWeekInfo(new Date(y, 11, 28, 12, 0, 0, 0)).week;
        }

        function isoWeekToDate(isoYear, week, weekday) {
            var y = Number(isoYear);
            if (!Number.isFinite(y)) y = new Date().getFullYear();
            y = Math.round(y);
            var maxWeek = getIsoWeeksInYear(y);
            var w = Number(week);
            if (!Number.isFinite(w)) w = 1;
            w = Math.max(1, Math.min(maxWeek, Math.round(w)));
            var wd = Number(weekday);
            if (!Number.isFinite(wd)) wd = 1;
            wd = Math.max(1, Math.min(7, Math.round(wd)));
            var jan4 = new Date(y, 0, 4, 12, 0, 0, 0);
            var jan4Weekday = jan4.getDay();
            jan4Weekday = jan4Weekday === 0 ? 7 : jan4Weekday;
            var week1Monday = new Date(jan4);
            week1Monday.setDate(jan4.getDate() - jan4Weekday + 1);
            var target = new Date(week1Monday);
            target.setDate(week1Monday.getDate() + (w - 1) * 7 + (wd - 1));
            return target;
        }

        function getWeekdayShortName(weekday) {
            var names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            var idx = Number(weekday) - 1;
            if (!Number.isFinite(idx) || idx < 0 || idx >= names.length) return names[0];
            return names[idx];
        }

        function getCurrentIsoSnapshot() {
            var now = new Date();
            var iso = getIsoWeekInfo(now);
            return {
                isoYear: iso.isoYear,
                week: iso.week,
                weekday: iso.weekday,
                minutes: now.getHours() * 60 + now.getMinutes()
            };
        }

        var currentIsoSnapshot = getCurrentIsoSnapshot();
        var shadowClockMinutes = currentIsoSnapshot.minutes;
        var shadowClockLive = true;
        var shadowClockTimer = null;
        var shadowClockIsoYear = currentIsoSnapshot.isoYear;
        var shadowClockWeek = currentIsoSnapshot.week;
        var shadowClockWeekday = currentIsoSnapshot.weekday;
        var shadowWeekPanelOpen = false;

        function getLocalNowMinutes() {
            var now = new Date();
            return now.getHours() * 60 + now.getMinutes();
        }

        function formatClockMinutes(totalMinutes) {
            var m = Number(totalMinutes);
            if (!Number.isFinite(m)) m = 0;
            m = Math.max(0, Math.min(1439, Math.round(m)));
            var hh = Math.floor(m / 60);
            var mm = m % 60;
            return String(hh).padStart(2, '0') + ':' + String(mm).padStart(2, '0');
        }

        function formatIsoWeek(weekNumber) {
            var w = Number(weekNumber);
            if (!Number.isFinite(w)) w = 1;
            w = Math.max(1, Math.round(w));
            return 'W' + String(w).padStart(2, '0');
        }

        function setShadowWeekPanelOpen(opened) {
            shadowWeekPanelOpen = !!opened;
            if (shadowWeekPanel) {
                shadowWeekPanel.classList.toggle('hidden', !shadowWeekPanelOpen);
                shadowWeekPanel.setAttribute('aria-hidden', shadowWeekPanelOpen ? 'false' : 'true');
            }
            if (shadowWeekToggleBtn) {
                shadowWeekToggleBtn.setAttribute('aria-expanded', shadowWeekPanelOpen ? 'true' : 'false');
            }
        }

        function syncShadowDateFromNow() {
            var now = new Date();
            shadowClockMinutes = now.getHours() * 60 + now.getMinutes();
            var iso = getIsoWeekInfo(now);
            shadowClockIsoYear = iso.isoYear;
            shadowClockWeek = iso.week;
            shadowClockWeekday = iso.weekday;
        }

        function applyShadowClockTime(persist) {
            if (!Number.isFinite(shadowClockMinutes)) {
                shadowClockMinutes = getLocalNowMinutes();
            }
            shadowClockMinutes = Math.max(0, Math.min(1439, Math.round(shadowClockMinutes)));
            if (!Number.isFinite(shadowClockIsoYear)) {
                shadowClockIsoYear = getCurrentIsoSnapshot().isoYear;
            }
            shadowClockIsoYear = Math.max(1970, Math.min(3000, Math.round(shadowClockIsoYear)));
            var maxWeek = getIsoWeeksInYear(shadowClockIsoYear);
            if (!Number.isFinite(shadowClockWeek)) {
                shadowClockWeek = 1;
            }
            shadowClockWeek = Math.max(1, Math.min(maxWeek, Math.round(shadowClockWeek)));
            if (!Number.isFinite(shadowClockWeekday)) {
                shadowClockWeekday = getCurrentIsoSnapshot().weekday;
            }
            shadowClockWeekday = Math.max(1, Math.min(7, Math.round(shadowClockWeekday)));
            if (shadowTimeSlider) {
                shadowTimeSlider.value = String(shadowClockMinutes);
            }
            if (shadowTimeLabel) {
                shadowTimeLabel.textContent = formatClockMinutes(shadowClockMinutes);
            }
            if (shadowWeekSlider) {
                shadowWeekSlider.max = String(maxWeek);
                shadowWeekSlider.value = String(shadowClockWeek);
            }
            if (shadowWeekLabel) {
                shadowWeekLabel.textContent = formatIsoWeek(shadowClockWeek);
            }
            if (shadowWeekMeta) {
                shadowWeekMeta.textContent = 'Week ' + String(shadowClockWeek).padStart(2, '0') +
                    ' (' + getWeekdayShortName(shadowClockWeekday) + ')';
            }
            if (baseLayerOsmBuildings3d && typeof baseLayerOsmBuildings3d.date === 'function') {
                var d = isoWeekToDate(shadowClockIsoYear, shadowClockWeek, shadowClockWeekday);
                d.setHours(Math.floor(shadowClockMinutes / 60), shadowClockMinutes % 60, 0, 0);
                baseLayerOsmBuildings3d.date(d);
            }
            if (persist) {
                try {
                    localStorage.setItem('shadowClockMinutes', String(shadowClockMinutes));
                    localStorage.setItem('shadowClockIsoYear', String(shadowClockIsoYear));
                    localStorage.setItem('shadowClockWeek', String(shadowClockWeek));
                    localStorage.setItem('shadowClockWeekday', String(shadowClockWeekday));
                } catch (e) {}
            }
        }

        function stopShadowClockTimer() {
            if (shadowClockTimer) {
                clearInterval(shadowClockTimer);
                shadowClockTimer = null;
            }
        }

        function startShadowClockTimer() {
            stopShadowClockTimer();
            shadowClockTimer = setInterval(function () {
                if (!shadowClockLive) return;
                syncShadowDateFromNow();
                applyShadowClockTime(false);
            }, 30000);
        }

        function setShadowClockLiveMode(enabled, persist) {
            shadowClockLive = !!enabled;
            if (shadowLiveToggle) {
                shadowLiveToggle.checked = shadowClockLive;
            }
            if (shadowClockLive) {
                syncShadowDateFromNow();
                applyShadowClockTime(persist);
                startShadowClockTimer();
            } else {
                stopShadowClockTimer();
                applyShadowClockTime(persist);
            }
            if (persist) {
                try {
                    localStorage.setItem('shadowClockLive', shadowClockLive ? '1' : '0');
                } catch (e) {}
            }
        }

        function updateShadowClockVisibility() {
            if (!shadowClockControl) return;
            var visible = is3dBasemapMode(currentBasemapMode) && !!baseLayerOsmBuildings3d;
            shadowClockControl.classList.toggle('hidden', !visible);
            shadowClockControl.setAttribute('aria-hidden', visible ? 'false' : 'true');
            if (!visible) {
                setShadowWeekPanelOpen(false);
            }
        }

        if (usesOsmBasemap(currentBasemapMode)) {
            baseLayerOsm.addTo(map);
        } else {
            baseLayerPositron.addTo(map);
        }
        if (is3dBasemapMode(currentBasemapMode)) {
            if (baseLayerOsmBuildings3d) {
                apply3dBuildingStyle(currentBasemapMode);
                map.addLayer(baseLayerOsmBuildings3d);
                applyShadowClockTime(false);
                if (map.getZoom() < OSM_BUILDINGS_MIN_ZOOM) {
                    map.setZoom(OSM_BUILDINGS_MIN_ZOOM);
                }
            } else {
                currentBasemapMode = usesOsmBasemap(currentBasemapMode) ? 'osm' : 'positron';
            }
        }
        function updateCompassVisibility() {
            var visible = is3dBasemapMode(currentBasemapMode);
            if (mapCompass) {
                mapCompass.classList.toggle('hidden', !visible);
                mapCompass.setAttribute('aria-hidden', visible ? 'false' : 'true');
            }
            updateShadowClockVisibility();
        }
        function setBasemapMode(modeKey, persist) {
            var nextMode = BASEMAP_MODES[modeKey] ? modeKey : 'positron';
            currentBasemapMode = nextMode;
            if (map.hasLayer(baseLayerPositron)) map.removeLayer(baseLayerPositron);
            if (map.hasLayer(baseLayerOsm)) map.removeLayer(baseLayerOsm);
            if (baseLayerOsmBuildings3d && map.hasLayer(baseLayerOsmBuildings3d)) {
                map.removeLayer(baseLayerOsmBuildings3d);
            }
            if (usesOsmBasemap(currentBasemapMode)) {
                baseLayerOsm.addTo(map);
            } else {
                baseLayerPositron.addTo(map);
            }
            if (is3dBasemapMode(currentBasemapMode)) {
                if (baseLayerOsmBuildings3d) {
                    apply3dBuildingStyle(currentBasemapMode);
                    map.addLayer(baseLayerOsmBuildings3d);
                    applyShadowClockTime(false);
                    if (map.getZoom() < OSM_BUILDINGS_MIN_ZOOM) {
                        map.setZoom(OSM_BUILDINGS_MIN_ZOOM);
                    }
                } else {
                    currentBasemapMode = usesOsmBasemap(currentBasemapMode) ? 'osm' : 'positron';
                }
            }
            if (basemapSelect) {
                basemapSelect.value = currentBasemapMode;
            }
            updateCompassVisibility();
            if (persist) {
                try {
                    localStorage.setItem('basemapMode', currentBasemapMode);
                } catch (e) {}
            }
        }
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
        // remove popup's row if "visible-with-data"
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        // modify popup if contains media
        function addClassToPopupIfMedia(content, popup) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            var imgTd = tempDiv.querySelector('td img');
            if (imgTd) {
                var src = imgTd.getAttribute('src');
                if (/\.(jpg|jpeg|png|gif|bmp|webp|avif)$/i.test(src)) {
                    popup._contentNode.classList.add('media');
                    setTimeout(function() {
                        popup.update();
                    }, 10);
                } else if (/\.(mp3|wav|ogg|aac)$/i.test(src)) {
                    var audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = src;
                    imgTd.parentNode.replaceChild(audio, imgTd);
                    popup._contentNode.classList.add('media');
                    setTimeout(function() {
                        popup.setContent(tempDiv.innerHTML);
                        popup.update();
                    }, 10);
                } else if (/\.(mp4|webm|ogg|mov)$/i.test(src)) {
                    var video = document.createElement('video');
                    video.controls = true;
                    video.src = src;
                    video.style.width = "400px";
                    video.style.height = "300px";
                    video.style.maxHeight = "60vh";
                    video.style.maxWidth = "60vw";
                    imgTd.parentNode.replaceChild(video, imgTd);
                    popup._contentNode.classList.add('media');
                    // Aggiorna il popup quando il video carica i metadati
                    video.addEventListener('loadedmetadata', function() {
                        popup.update();
                    });
                    setTimeout(function() {
                        popup.setContent(tempDiv.innerHTML);
                        popup.update();
                    }, 10);
                } else {
                    popup._contentNode.classList.remove('media');
                }
            } else {
                popup._contentNode.classList.remove('media');
            }
        }
        var zoomControl = L.control.zoom({
            position: 'bottomright'
        }).addTo(map);
        var labelToggleBtn = document.getElementById('labelToggleBtn');
        var mapLabelsBlock = document.getElementById('mapLabelsBlock');
        var labelsVisible = false;
        var feedbackBlock = document.querySelector('.map-top-controls .map-feedback-block');
        function updateFeedbackBlockVisibility() {
            if (!feedbackBlock) return;
            var shouldShow = labelsVisible || !paletteSliderCollapsed;
            feedbackBlock.classList.toggle('hidden', !shouldShow);
            if (!shouldShow) {
                setFeedbackFormOpen(false);
            }
        }
        if (labelToggleBtn && mapLabelsBlock) {
            labelToggleBtn.addEventListener('click', function () {
                labelsVisible = !labelsVisible;
                if (labelsVisible) {
                    mapLabelsBlock.classList.remove('hidden');
                    labelToggleBtn.textContent = 'Hide labels';
                } else {
                    mapLabelsBlock.classList.add('hidden');
                    labelToggleBtn.textContent = 'Show labels';
                }
                updateFeedbackBlockVisibility();
            });
        }
        var gotoLeppaBtn = document.getElementById('gotoLeppaBtn');
        var gotoKivenlahtiBtn = document.getElementById('gotoKivenlahtiBtn');
        var gotoMankkaaBtn = document.getElementById('gotoMankkaaBtn');
        if (gotoLeppaBtn) {
            gotoLeppaBtn.addEventListener('click', function () {
                map.fitBounds(LEPPA_BOUNDS, {padding: [20, 20]});
            });
        }
        if (gotoKivenlahtiBtn) {
            gotoKivenlahtiBtn.addEventListener('click', function () {
                map.fitBounds(KIVENLAHTI_BOUNDS, {padding: [20, 20]});
            });
        }
        if (gotoMankkaaBtn) {
            gotoMankkaaBtn.addEventListener('click', function () {
                map.fitBounds(MANKKAA_BOUNDS, {padding: [20, 20]});
            });
        }
        var scoreLegendBar = document.getElementById('scoreLegendBar');
        var scoreLegendLowLabel = document.getElementById('scoreLegendLowLabel');
        var scoreLegendHighLabel = document.getElementById('scoreLegendHighLabel');
        var paletteSliderUi = document.getElementById('paletteSliderUi');
        var paletteSliderBody = document.getElementById('paletteSliderBody');
        var paletteSliderToggleBtn = document.getElementById('paletteSliderToggleBtn');
        var scorePaletteSlider = document.getElementById('scorePaletteSlider');
        var paletteSliderCurrent = document.getElementById('paletteSliderCurrent');
        var paletteSliderTicks = document.querySelectorAll('.palette-slider-tick');
        var basemapSelect = document.getElementById('basemapSelect');
        var mapillaryViewSelect = document.getElementById('mapillaryViewSelect');
        var groupPhotosToggle = document.getElementById('groupPhotosToggle');
        var mapillaryDataToggle = document.getElementById('mapillaryDataToggle');
        var feedbackToggleBtn = document.getElementById('feedbackToggleBtn');
        var feedbackForm = document.getElementById('feedbackForm');
        var feedbackRating = document.getElementById('feedbackRating');
        var feedbackRatingValue = document.getElementById('feedbackRatingValue');
        var feedbackOpinion = document.getElementById('feedbackOpinion');
        var feedbackSubmitBtn = document.getElementById('feedbackSubmitBtn');
        var feedbackStatus = document.getElementById('feedbackStatus');
        var feedbackMapHash = document.getElementById('feedbackMapHash');
        var feedbackMapCenterLat = document.getElementById('feedbackMapCenterLat');
        var feedbackMapCenterLon = document.getElementById('feedbackMapCenterLon');
        var feedbackMapZoom = document.getElementById('feedbackMapZoom');
        var feedbackSelectedPlace = document.getElementById('feedbackSelectedPlace');
        var feedbackSubmittedAt = document.getElementById('feedbackSubmittedAt');
        var feedbackSiteOrigin = document.getElementById('feedbackSiteOrigin');
        var mapCompass = document.getElementById('mapCompass');
        var shadowClockControl = document.getElementById('shadowClockControl');
        var shadowTimeSlider = document.getElementById('shadowTimeSlider');
        var shadowTimeLabel = document.getElementById('shadowTimeLabel');
        var shadowWeekToggleBtn = document.getElementById('shadowWeekToggleBtn');
        var shadowWeekPanel = document.getElementById('shadowWeekPanel');
        var shadowWeekLabel = document.getElementById('shadowWeekLabel');
        var shadowWeekMeta = document.getElementById('shadowWeekMeta');
        var shadowWeekSlider = document.getElementById('shadowWeekSlider');
        var shadowNowBtn = document.getElementById('shadowNowBtn');
        var shadowLiveToggle = document.getElementById('shadowLiveToggle');
        var creditsToggleBtn = document.getElementById('creditsToggleBtn');
        var creditsPanel = document.getElementById('creditsPanel');
        if (creditsToggleBtn && creditsPanel) {
            creditsToggleBtn.addEventListener('click', function () {
                var hidden = creditsPanel.classList.toggle('hidden');
                creditsToggleBtn.textContent = hidden ? 'Show credits & privacy' : 'Hide credits & privacy';
            });
        }
        var feedbackFormOpen = false;
        var latestSelectedPlaceLabel = '';
        function setFeedbackStatus(message, isError) {
            if (!feedbackStatus) return;
            feedbackStatus.textContent = message || '';
            feedbackStatus.classList.toggle('error', !!isError);
        }
        function setFeedbackFormOpen(open) {
            feedbackFormOpen = !!open;
            if (feedbackForm) {
                feedbackForm.classList.toggle('hidden', !feedbackFormOpen);
            }
            if (feedbackToggleBtn) {
                feedbackToggleBtn.setAttribute('aria-expanded', feedbackFormOpen ? 'true' : 'false');
            }
        }
        function feedbackRatingToColor(value) {
            var v = Number(value);
            if (!Number.isFinite(v)) v = 0;
            v = Math.max(0, Math.min(10, v));
            var t = v / 10;
            var sat = Math.round(t * 100);
            var light = Math.round(62 - (t * 14));
            return 'hsl(132,' + sat + '%,' + light + '%)';
        }
        function updateFeedbackRatingDisplay() {
            if (!feedbackRating || !feedbackRatingValue) return;
            var val = Number(feedbackRating.value);
            if (!Number.isFinite(val)) val = 0;
            val = Math.max(0, Math.min(10, Math.round(val)));
            feedbackRatingValue.textContent = String(val);
            var color = feedbackRatingToColor(val);
            feedbackRating.style.accentColor = color;
            feedbackRatingValue.style.color = color;
        }
        function updateFeedbackContextFields() {
            if (feedbackMapHash) {
                feedbackMapHash.value = String(window.location.hash || '');
            }
            var center = map.getCenter ? map.getCenter() : null;
            if (center) {
                if (feedbackMapCenterLat) feedbackMapCenterLat.value = Number(center.lat).toFixed(6);
                if (feedbackMapCenterLon) feedbackMapCenterLon.value = Number(center.lng).toFixed(6);
            }
            if (feedbackMapZoom && map.getZoom) {
                feedbackMapZoom.value = String(map.getZoom());
            }
            if (feedbackSelectedPlace) {
                feedbackSelectedPlace.value = latestSelectedPlaceLabel || '';
            }
            if (feedbackSubmittedAt) {
                feedbackSubmittedAt.value = new Date().toISOString();
            }
            if (feedbackSiteOrigin) {
                feedbackSiteOrigin.value = String(window.location.origin || '');
            }
        }
        function isLocalPreviewMode() {
            var host = String(window.location.hostname || '').toLowerCase();
            var protocol = String(window.location.protocol || '').toLowerCase();
            return protocol === 'file:' || host === 'localhost' || host === '127.0.0.1';
        }
        function encodeNetlifyForm(dataObj) {
            var pairs = [];
            Object.keys(dataObj || {}).forEach(function (key) {
                var value = dataObj[key];
                if (value === undefined || value === null) value = '';
                pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(value)));
            });
            return pairs.join('&');
        }
        function getFeedbackPayloadObject() {
            if (!feedbackForm) return {};
            updateFeedbackContextFields();
            var obj = {};
            var fd = new FormData(feedbackForm);
            fd.forEach(function (val, key) {
                if (key === 'bot-field') return;
                obj[key] = String(val);
            });
            obj['form-name'] = 'ai_sentiment_poll';
            return obj;
        }
        if (feedbackToggleBtn) {
            feedbackToggleBtn.addEventListener('click', function () {
                setFeedbackFormOpen(!feedbackFormOpen);
                if (feedbackFormOpen && feedbackOpinion) {
                    feedbackOpinion.focus();
                }
            });
        }
        if (feedbackRating) {
            feedbackRating.addEventListener('input', updateFeedbackRatingDisplay);
            feedbackRating.addEventListener('change', updateFeedbackRatingDisplay);
        }
        if (feedbackForm) {
            feedbackForm.addEventListener('submit', function (e) {
                e.preventDefault();
                setFeedbackStatus('', false);
                var payload = getFeedbackPayloadObject();
                if (!payload.opinion || !String(payload.opinion).trim()) {
                    setFeedbackStatus('Please write a short opinion before sending.', true);
                    if (feedbackOpinion) feedbackOpinion.focus();
                    return;
                }
                if (isLocalPreviewMode()) {
                    setFeedbackStatus('Local preview mode: deploy to Netlify to submit this poll.', true);
                    return;
                }
                if (feedbackSubmitBtn) feedbackSubmitBtn.disabled = true;
                var body = encodeNetlifyForm(payload);
                fetch('/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Accept': 'application/json'
                    },
                    body: body
                }).then(function (response) {
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    feedbackForm.reset();
                    updateFeedbackRatingDisplay();
                    setFeedbackStatus('Thanks. Feedback sent to Netlify.', false);
                    setFeedbackFormOpen(false);
                }).catch(function () {
                    setFeedbackStatus('Could not send to Netlify Forms. Check site deploy and forms setup.', true);
                }).finally(function () {
                    if (feedbackSubmitBtn) feedbackSubmitBtn.disabled = false;
                });
            });
        }
        setFeedbackFormOpen(false);
        updateFeedbackRatingDisplay();
        var photoLightbox = document.getElementById('photoLightbox');
        var photoLightboxImg = document.getElementById('photoLightboxImg');
        var photoZoomInBtn = document.getElementById('photoZoomInBtn');
        var photoZoomOutBtn = document.getElementById('photoZoomOutBtn');
        var photoZoomResetBtn = document.getElementById('photoZoomResetBtn');
        var photoCloseBtn = document.getElementById('photoCloseBtn');
        var photoZoom = 1;
        function setPhotoZoom(z) {
            photoZoom = Math.max(0.5, Math.min(4, z));
            if (photoLightboxImg) {
                photoLightboxImg.style.transform = 'scale(' + photoZoom + ')';
            }
        }
        function openPhotoLightbox(src) {
            if (!photoLightbox || !photoLightboxImg) return;
            photoLightboxImg.src = src;
            setPhotoZoom(1);
            photoLightbox.classList.remove('hidden');
            photoLightbox.setAttribute('aria-hidden', 'false');
            if (photoLightbox.requestFullscreen) {
                photoLightbox.requestFullscreen().catch(function () {});
            }
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(function () {});
            }
        }
        function closePhotoLightbox() {
            if (!photoLightbox || !photoLightboxImg) return;
            photoLightbox.classList.add('hidden');
            photoLightbox.setAttribute('aria-hidden', 'true');
            photoLightboxImg.removeAttribute('src');
            if (document.fullscreenElement && document.exitFullscreen) {
                document.exitFullscreen().catch(function () {});
            }
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }
        }
        function bindPopupImageInteractions(popup) {
            if (!popup || !popup._contentNode) return;
            var imgs = popup._contentNode.querySelectorAll('img');
            imgs.forEach(function (img) {
                if ((!img.getAttribute('src') || img.getAttribute('src') === '') && img.dataset.photoSrc) {
                    img.setAttribute('src', img.dataset.photoSrc);
                }
                img.classList.add('popup-photo-thumb');
                if (!img.dataset.lightboxBound) {
                    img.dataset.lightboxBound = '1';
                    img.addEventListener('click', function () {
                        openPhotoLightbox(img.getAttribute('src') || img.dataset.photoSrc);
                    });
                }
            });
            var buttons = popup._contentNode.querySelectorAll('.photo-open-btn');
            buttons.forEach(function (btn) {
                if (!btn.dataset.lightboxBound) {
                    btn.dataset.lightboxBound = '1';
                    btn.addEventListener('click', function (ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        var src = btn.getAttribute('data-photo-src');
                        if (src) openPhotoLightbox(src);
                    });
                }
            });
        }
        if (photoZoomInBtn) photoZoomInBtn.addEventListener('click', function () { setPhotoZoom(photoZoom + 0.2); });
        if (photoZoomOutBtn) photoZoomOutBtn.addEventListener('click', function () { setPhotoZoom(photoZoom - 0.2); });
        if (photoZoomResetBtn) photoZoomResetBtn.addEventListener('click', function () { setPhotoZoom(1); });
        if (photoCloseBtn) photoCloseBtn.addEventListener('click', closePhotoLightbox);
        if (photoLightbox) {
            photoLightbox.addEventListener('click', function (e) {
                if (e.target === photoLightbox) closePhotoLightbox();
            });
            photoLightbox.addEventListener('wheel', function (e) {
                e.preventDefault();
                setPhotoZoom(photoZoom + (e.deltaY < 0 ? 0.12 : -0.12));
            }, { passive: false });
        }
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') closePhotoLightbox();
        });
        // Safari-friendly delegated handler for dynamic popup content.
        document.addEventListener('click', function (e) {
            var target = e.target;
            if (!target) return;
            if (target.classList && target.classList.contains('popup-photo-thumb')) {
                e.preventDefault();
                openPhotoLightbox(target.getAttribute('src') || target.getAttribute('data-photo-src'));
                return;
            }
            if (target.classList && target.classList.contains('photo-open-btn')) {
                e.preventDefault();
                var src = target.getAttribute('data-photo-src');
                if (src) openPhotoLightbox(src);
            }
        }, true);
        var bounds_group = new L.featureGroup([]);
        function setBounds() {
        }
        // Basemap can be switched between Positron/OpenStreetMap, with optional 3D building overlays.
        function pop_leppavaara_photo_index_ai_1(feature, layer) {
            var p = feature.properties || {};
            var nameKey = String(p['new_name'] || p['original_name'] || '');
            if (/^MankkaaDark_/i.test(nameKey) && layer && layer.bindTooltip) {
                layer.bindTooltip('|', {
                    permanent: true,
                    direction: 'center',
                    className: 'mankkaa-dark-line-tooltip',
                    opacity: 1,
                    interactive: false
                });
            }
            function getBaseMarkerStyle() {
                return style_spt_ai_combined_1_0(feature);
            }
            var placeVal = p['Place_name'] || p['street_name'] || p['place_slug'] || '';
            var placeText = String(placeVal || p['place_slug'] || '')
                .replace(/_/g, ' ')
                .trim();
            if (!placeText || placeText.toLowerCase() === 'unknown place') {
                placeText = 'Place';
            }
            // Title-case each word for cleaner labels (e.g. Hatsinanpuisto, Perkkaantie).
            placeText = placeText
                .split(/\s+/)
                .map(function (w) { return w ? w.charAt(0).toUpperCase() + w.slice(1).toLowerCase() : w; })
                .join(' ');
            var seqRaw = Number(p['location_sequence']);
            var seqText = Number.isFinite(seqRaw) ? String(Math.round(seqRaw)).padStart(2, '0') : '00';
            var areaPrefix = 'Leppävaara';
            if (/^Kivenlahti_/i.test(nameKey)) {
                areaPrefix = 'Kivenlahti';
            } else if (/^Mankkaa/i.test(nameKey)) {
                areaPrefix = 'Mankkaa';
            }
            var nameVal = areaPrefix + ' #' + seqText + ' ' + placeText;
            var lonVal = p['longitude'];
            var latVal = p['latitude'];
            var lonLatVal = '';
            if (lonVal !== null && lonVal !== undefined && latVal !== null && latVal !== undefined) {
                lonLatVal = String(lonVal).replace(/'/g, '\\\'') + ', ' + String(latVal).replace(/'/g, '\\\'');
            }

            function row(label, value) {
                if (value === null || value === undefined || value === '') return '';
                return '<tr><th scope="row">' + label + '</th><td>' +
                    autolinker.link(String(value).replace(/'/g, '\\\'').toLocaleString()) +
                    '</td></tr>';
            }

            var rows = '';
            rows += row('Name', nameVal);
            rows += row('Lon, Lat', lonLatVal);
            rows += row('Place', placeVal);
            rows += row('AI Social', p['AI-Social_environment']);
            rows += row('AI Active', p['AI-Active_environment']);
            rows += row('AI Aesthetic', p['AI-Aesthetic_environment']);
            rows += row('AI Atmosphere', p['AI-Atmosphere']);
            rows += row('AI Significance', p['AI_significance']);
            rows += row('AI overall score (-5 to +5)', p['AI_overall']);
            rows += row('AI reasoning Social', p['AI_Social_environment_reason']);
            rows += row('AI reasoning Active', p['AI_Active_environment_reason']);
            rows += row('AI reasoning Aesthetic', p['AI_Aesthetic_environment_reason']);
            rows += row('AI reasoning Atmosphere', p['AI_Atmosphere_reason']);
            rows += row('AI reasoning Significance', p['AI_significance_reason']);

            if (p['photo_path']) {
                var img = String(p['photo_path'])
                    .replace(/[\\/:]/g, '_').trim().replace(/'/g, '\\\'').replace(/"/g, '&quot;');
                var src = 'images/' + img;
                rows += '<tr><th scope="row">Photo</th><td>' +
                    '<img class="popup-photo-thumb" loading="lazy" decoding="async" data-photo-src="' + src + '" alt="Photo">' +
                    '<div class="popup-photo-actions"><button class="photo-open-btn" type="button" data-photo-src="' + src + '">Open fullscreen</button></div>' +
                    '</td></tr>';
            }

            var popupContent = '<table>' + rows + '</table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
				layer.on('popupopen', function(e) {
					addClassToPopupIfMedia(content, e.popup);
                bindPopupImageInteractions(e.popup);
                latestSelectedPlaceLabel = nameVal || '';
                var baseMarkerStyle = getBaseMarkerStyle();
                var openRadius = (baseMarkerStyle.radius || 6) * 1.3;
                layer.setStyle({
                    radius: openRadius,
                    color: 'rgba(0,0,0,1.0)',
                    dashArray: baseMarkerStyle.dashArray || '',
                    fillColor: 'rgba(0,0,0,1.0)',
                    weight: baseMarkerStyle.weight || 1,
                    fillOpacity: baseMarkerStyle.fillOpacity || 1,
                    opacity: baseMarkerStyle.opacity || 1
                });
				});
            layer.on('popupclose', function() {
                layer.setStyle(getBaseMarkerStyle());
				});
			layer.bindPopup(content, {
                maxWidth: Math.min(900, Math.round(window.innerWidth * 0.92)),
                minWidth: Math.min(260, Math.round(window.innerWidth * 0.62)),
                maxHeight: Math.max(260, Math.round(window.innerHeight * 0.72)),
                keepInView: true,
                autoPanPaddingTopLeft: [16, 90],
                autoPanPaddingBottomRight: [16, 90]
            });
        }

        var SCORE_PALETTE_MODES = {
            normal: {
                label: 'Trichromacy',
                neg: [165, 15, 21],
                mid: [255, 235, 170],
                pos: [0, 104, 55],
                legendGradient: 'linear-gradient(90deg, #a50f15 0%, #de2d26 25%, #ffebb0 50%, #31a354 75%, #006837 100%)',
                lowLabel: 'Red = lower score',
                highLabel: 'Green = higher score'
            },
            redgreen: {
                label: 'Red-Green CVD',
                neg: [44, 123, 182],
                mid: [247, 247, 247],
                pos: [230, 97, 1],
                legendGradient: 'linear-gradient(90deg, #2c7bb6 0%, #a8d5e9 25%, #f7f7f7 50%, #fbc07d 75%, #e66101 100%)',
                lowLabel: 'Blue = lower score',
                highLabel: 'Orange = higher score'
            },
            blueyellow: {
                label: 'Blue-Yellow CVD',
                neg: [123, 50, 148],
                mid: [247, 247, 247],
                pos: [0, 136, 136],
                legendGradient: 'linear-gradient(90deg, #7b3294 0%, #c2a5cf 25%, #f7f7f7 50%, #92c5de 75%, #008888 100%)',
                lowLabel: 'Purple = lower score',
                highLabel: 'Teal = higher score'
            },
            mono: {
                label: 'Monochrome',
                neg: [30, 30, 30],
                mid: [145, 145, 145],
                pos: [240, 240, 240],
                legendGradient: 'linear-gradient(90deg, #1e1e1e 0%, #666666 25%, #919191 50%, #c6c6c6 75%, #f0f0f0 100%)',
                lowLabel: 'Darker = lower score',
                highLabel: 'Lighter = higher score'
            }
        };
        var SCORE_PALETTE_ORDER = ['normal', 'redgreen', 'blueyellow', 'mono'];
        var currentScorePaletteMode = 'normal';
        var paletteSliderCollapsed = false;
        var currentMapillaryView = 'dots';
        var showGroupPhotos = true;
        var showMapillaryData = true;
        try {
            var savedScorePaletteMode = localStorage.getItem('scorePaletteMode');
            if (savedScorePaletteMode && SCORE_PALETTE_MODES[savedScorePaletteMode]) {
                currentScorePaletteMode = savedScorePaletteMode;
            }
            paletteSliderCollapsed = localStorage.getItem('scorePaletteCollapsed') === '1';
            var savedMapillaryView = localStorage.getItem('mapillaryOverlayMode');
            if (savedMapillaryView === 'dots' || savedMapillaryView === 'heat') {
                currentMapillaryView = savedMapillaryView;
            }
            var savedGroupPhotos = localStorage.getItem('showGroupPhotos');
            if (savedGroupPhotos === '0' || savedGroupPhotos === '1') {
                showGroupPhotos = savedGroupPhotos === '1';
            }
            var savedMapillaryData = localStorage.getItem('showMapillaryData');
            if (savedMapillaryData === '0' || savedMapillaryData === '1') {
                showMapillaryData = savedMapillaryData === '1';
            }
            var savedShadowClockMinutes = Number(localStorage.getItem('shadowClockMinutes'));
            if (Number.isFinite(savedShadowClockMinutes)) {
                shadowClockMinutes = Math.max(0, Math.min(1439, Math.round(savedShadowClockMinutes)));
            } else {
                shadowClockMinutes = getLocalNowMinutes();
            }
            var savedShadowClockIsoYear = Number(localStorage.getItem('shadowClockIsoYear'));
            if (Number.isFinite(savedShadowClockIsoYear)) {
                shadowClockIsoYear = Math.max(1970, Math.min(3000, Math.round(savedShadowClockIsoYear)));
            }
            var savedShadowClockWeekday = Number(localStorage.getItem('shadowClockWeekday'));
            if (Number.isFinite(savedShadowClockWeekday)) {
                shadowClockWeekday = Math.max(1, Math.min(7, Math.round(savedShadowClockWeekday)));
            }
            var savedShadowClockWeek = Number(localStorage.getItem('shadowClockWeek'));
            if (Number.isFinite(savedShadowClockWeek)) {
                var savedMaxWeek = getIsoWeeksInYear(shadowClockIsoYear);
                shadowClockWeek = Math.max(1, Math.min(savedMaxWeek, Math.round(savedShadowClockWeek)));
            }
            var savedShadowClockLive = localStorage.getItem('shadowClockLive');
            if (savedShadowClockLive === '0' || savedShadowClockLive === '1') {
                shadowClockLive = savedShadowClockLive === '1';
            }
        } catch (e) {}

        function paletteModeToIndex(modeKey) {
            var idx = SCORE_PALETTE_ORDER.indexOf(modeKey);
            return idx >= 0 ? idx : 0;
        }

        function paletteIndexToMode(indexValue) {
            var idx = Number(indexValue);
            if (!Number.isFinite(idx)) return 'normal';
            idx = Math.max(0, Math.min(SCORE_PALETTE_ORDER.length - 1, Math.round(idx)));
            return SCORE_PALETTE_ORDER[idx];
        }

        function getCurrentScorePalette() {
            return SCORE_PALETTE_MODES[currentScorePaletteMode] || SCORE_PALETTE_MODES.normal;
        }

        function updatePaletteSliderUi() {
            var mode = getCurrentScorePalette();
            if (scorePaletteSlider) {
                scorePaletteSlider.value = String(paletteModeToIndex(currentScorePaletteMode));
            }
            if (paletteSliderCurrent) {
                paletteSliderCurrent.textContent = mode.label;
            }
            if (paletteSliderTicks && paletteSliderTicks.length) {
                paletteSliderTicks.forEach(function (tick) {
                    var isActive = tick.getAttribute('data-mode') === currentScorePaletteMode;
                    tick.classList.toggle('active', isActive);
                });
            }
        }

        function applyLegendPalette() {
            var mode = getCurrentScorePalette();
            if (scoreLegendBar) {
                scoreLegendBar.style.background = mode.legendGradient;
            }
            if (scoreLegendLowLabel) {
                scoreLegendLowLabel.textContent = mode.lowLabel;
            }
            if (scoreLegendHighLabel) {
                scoreLegendHighLabel.textContent = mode.highLabel;
            }
        }

        function setPaletteSliderCollapsed(collapsed, persist) {
            paletteSliderCollapsed = !!collapsed;
            if (paletteSliderUi) {
                paletteSliderUi.classList.toggle('collapsed', paletteSliderCollapsed);
            }
            if (paletteSliderBody) {
                paletteSliderBody.setAttribute('aria-hidden', paletteSliderCollapsed ? 'true' : 'false');
            }
            if (paletteSliderToggleBtn) {
                paletteSliderToggleBtn.textContent = paletteSliderCollapsed ? 'Show color mode' : 'Hide color mode';
                paletteSliderToggleBtn.setAttribute('aria-expanded', paletteSliderCollapsed ? 'false' : 'true');
            }
            if (persist) {
                try {
                    localStorage.setItem('scorePaletteCollapsed', paletteSliderCollapsed ? '1' : '0');
                } catch (e) {}
            }
            updateFeedbackBlockVisibility();
        }

        function refreshScorePaletteRendering() {
            applyLegendPalette();
            if (layer_spt_ai_combined_1 && layer_spt_ai_combined_1.eachLayer) {
                layer_spt_ai_combined_1.eachLayer(function (markerLayer) {
                    if (!markerLayer || !markerLayer.feature || !markerLayer.setStyle) return;
                    markerLayer.setStyle(style_spt_ai_combined_1_0(markerLayer.feature));
                });
            }
            updateMapillaryOverlayStyles();
            applyAreaAverageButtonStyles();
        }

        function setScorePaletteMode(modeKey, persist) {
            var nextMode = SCORE_PALETTE_MODES[modeKey] ? modeKey : 'normal';
            currentScorePaletteMode = nextMode;
            updatePaletteSliderUi();
            refreshScorePaletteRendering();
            if (persist) {
                try {
                    localStorage.setItem('scorePaletteMode', currentScorePaletteMode);
                } catch (e) {}
            }
        }

        function clampScore(v) {
            return Math.max(-5, Math.min(5, v));
        }

        function scoreToColor(score) {
            var s = clampScore(score);
            var t;
            var start;
            var end;
            var palette = getCurrentScorePalette();
            function mix(a, b, k) {
                return Math.round(a + (b - a) * k);
            }
            if (s <= 0) {
                t = (s + 5) / 5; // -5..0 => 0..1
                start = palette.neg;
                end = palette.mid;
            } else {
                t = s / 5; // 0..5 => 0..1
                start = palette.mid;
                end = palette.pos;
            }
            return 'rgb(' +
                mix(start[0], end[0], t) + ',' +
                mix(start[1], end[1], t) + ',' +
                mix(start[2], end[2], t) +
            ')';
        }

        function getMapillaryFeatureScore(feature) {
            var p = (feature && feature.properties) ? feature.properties : {};
            var candidates = [
                p['score'],
                p['AI overall score (-5 to +5)'],
                p['AI_overall'],
                p['ai_overall'],
                p['ai_sentiment_score']
            ];
            for (var i = 0; i < candidates.length; i++) {
                var v = Number(candidates[i]);
                if (Number.isFinite(v)) return clampScore(v);
            }
            return 0;
        }

        function buildMapillaryRoadBandSegments(geojson, options) {
            var opts = options || {};
            var snapMeters = Number.isFinite(opts.snapMeters) ? Math.max(1, opts.snapMeters) : 3.5;
            var connectDistanceM = Number.isFinite(opts.connectDistanceM) ? Math.max(8, opts.connectDistanceM) : 28;
            var minDistanceM = Number.isFinite(opts.minDistanceM) ? Math.max(1, opts.minDistanceM) : 2.5;
            var maxScoreDelta = Number.isFinite(opts.maxScoreDelta) ? Math.max(0, opts.maxScoreDelta) : 1.35;
            var axisRadiusM = Number.isFinite(opts.axisRadiusM) ? Math.max(12, opts.axisRadiusM) : 32;
            var minAxisAlignment = Number.isFinite(opts.minAxisAlignment) ? Math.max(0, Math.min(1, opts.minAxisAlignment)) : 0.55;
            var supportCorridorM = Number.isFinite(opts.supportCorridorM) ? Math.max(1.5, opts.supportCorridorM) : 4.5;
            var supportMinDistanceM = Number.isFinite(opts.supportMinDistanceM) ? Math.max(8, opts.supportMinDistanceM) : 18;
            var minSupportPoints = Number.isFinite(opts.minSupportPoints) ? Math.max(0, Math.round(opts.minSupportPoints)) : 1;
            var degreeLimit = Number.isFinite(opts.degreeLimit) ? Math.max(1, Math.round(opts.degreeLimit)) : 2;
            var minTurnAngleDeg = Number.isFinite(opts.minTurnAngleDeg) ? Math.max(0, Math.min(179, opts.minTurnAngleDeg)) : 60;
            var features = geojson && geojson.features ? geojson.features : [];
            if (!features.length) return [];

            function toCellKey(x, y, cellSize) {
                return Math.floor(x / cellSize) + ':' + Math.floor(y / cellSize);
            }

            function dot(ax, ay, bx, by) {
                return ax * bx + ay * by;
            }

            function maybeUnit(vx, vy) {
                var m = Math.sqrt(vx * vx + vy * vy);
                if (!Number.isFinite(m) || m < 1e-6) return null;
                return { x: vx / m, y: vy / m };
            }

            function headingAlignment(unitVec, axisVec) {
                if (!unitVec || !axisVec) return 1;
                return Math.abs(dot(unitVec.x, unitVec.y, axisVec.x, axisVec.y));
            }

            function segmentSupportCount(nodeA, nodeB, nodesList, gridByCell, cellSize) {
                var dx = nodeB.x - nodeA.x;
                var dy = nodeB.y - nodeA.y;
                var segLen = Math.sqrt(dx * dx + dy * dy);
                if (!Number.isFinite(segLen) || segLen < 1e-6) return 0;

                var minX = Math.min(nodeA.x, nodeB.x) - supportCorridorM;
                var maxX = Math.max(nodeA.x, nodeB.x) + supportCorridorM;
                var minY = Math.min(nodeA.y, nodeB.y) - supportCorridorM;
                var maxY = Math.max(nodeA.y, nodeB.y) + supportCorridorM;
                var cMinX = Math.floor(minX / cellSize);
                var cMaxX = Math.floor(maxX / cellSize);
                var cMinY = Math.floor(minY / cellSize);
                var cMaxY = Math.floor(maxY / cellSize);

                var support = 0;
                var seenNode = {};
                for (var gx = cMinX; gx <= cMaxX; gx++) {
                    for (var gy = cMinY; gy <= cMaxY; gy++) {
                        var ids = gridByCell[gx + ':' + gy];
                        if (!ids) continue;
                        for (var ii = 0; ii < ids.length; ii++) {
                            var idx = ids[ii];
                            if (idx === nodeA.idx || idx === nodeB.idx) continue;
                            if (seenNode[idx]) continue;
                            seenNode[idx] = true;
                            var n = nodesList[idx];
                            var vx = n.x - nodeA.x;
                            var vy = n.y - nodeA.y;
                            var t = dot(vx, vy, dx, dy) / (segLen * segLen);
                            if (t <= 0.06 || t >= 0.94) continue;
                            var px = nodeA.x + t * dx;
                            var py = nodeA.y + t * dy;
                            var ox = n.x - px;
                            var oy = n.y - py;
                            var perp = Math.sqrt(ox * ox + oy * oy);
                            if (perp <= supportCorridorM) {
                                support += 1;
                            }
                        }
                    }
                }
                return support;
            }

            function localAxisForNode(nodeIndex, nodesList, gridByCell, cellSize) {
                var node = nodesList[nodeIndex];
                var centerX = Math.floor(node.x / cellSize);
                var centerY = Math.floor(node.y / cellSize);
                var searchR = Math.max(1, Math.ceil(axisRadiusM / cellSize));
                var neighbors = [];
                var seen = {};
                for (var dx = -searchR; dx <= searchR; dx++) {
                    for (var dy = -searchR; dy <= searchR; dy++) {
                        var ids = gridByCell[(centerX + dx) + ':' + (centerY + dy)];
                        if (!ids) continue;
                        for (var i = 0; i < ids.length; i++) {
                            var ni = ids[i];
                            if (ni === nodeIndex || seen[ni]) continue;
                            seen[ni] = true;
                            var n = nodesList[ni];
                            var ox = n.x - node.x;
                            var oy = n.y - node.y;
                            var d = Math.sqrt(ox * ox + oy * oy);
                            if (d <= axisRadiusM) neighbors.push({ x: ox, y: oy });
                        }
                    }
                }
                if (neighbors.length < 3) return null;
                var sxx = 0;
                var sxy = 0;
                var syy = 0;
                for (var k = 0; k < neighbors.length; k++) {
                    var nx = neighbors[k].x;
                    var ny = neighbors[k].y;
                    sxx += nx * nx;
                    sxy += nx * ny;
                    syy += ny * ny;
                }
                if ((sxx + syy) < 1e-6) return null;
                var theta = 0.5 * Math.atan2(2 * sxy, sxx - syy);
                return { x: Math.cos(theta), y: Math.sin(theta) };
            }

            function turnAngleDeg(fromNode, centerNode, toNode) {
                var v1 = maybeUnit(fromNode.x - centerNode.x, fromNode.y - centerNode.y);
                var v2 = maybeUnit(toNode.x - centerNode.x, toNode.y - centerNode.y);
                if (!v1 || !v2) return 180;
                var c = Math.max(-1, Math.min(1, dot(v1.x, v1.y, v2.x, v2.y)));
                return Math.acos(c) * 180 / Math.PI;
            }

            var rawPoints = [];
            var latSum = 0;
            var lonSum = 0;
            for (var fi = 0; fi < features.length; fi++) {
                var f = features[fi] || {};
                var g = f.geometry || {};
                var c = g.coordinates || [];
                if (!Array.isArray(c) || c.length < 2) continue;
                var lon = Number(c[0]);
                var lat = Number(c[1]);
                if (!Number.isFinite(lon) || !Number.isFinite(lat)) continue;
                rawPoints.push({ lat: lat, lon: lon, score: getMapillaryFeatureScore(f) });
                latSum += lat;
                lonSum += lon;
            }
            if (!rawPoints.length) return [];

            var originLat = latSum / rawPoints.length;
            var originLon = lonSum / rawPoints.length;
            var metersPerLat = 111320;
            var metersPerLon = Math.max(1, 111320 * Math.cos(originLat * Math.PI / 180));

            var snappedNodesByKey = {};
            for (var rp = 0; rp < rawPoints.length; rp++) {
                var pt = rawPoints[rp];
                var x = (pt.lon - originLon) * metersPerLon;
                var y = (pt.lat - originLat) * metersPerLat;
                var gx = Math.round(x / snapMeters);
                var gy = Math.round(y / snapMeters);
                var key = gx + ':' + gy;
                if (!snappedNodesByKey[key]) {
                    snappedNodesByKey[key] = {
                        sumLat: 0,
                        sumLon: 0,
                        sumX: 0,
                        sumY: 0,
                        sumScore: 0,
                        count: 0
                    };
                }
                var agg = snappedNodesByKey[key];
                agg.sumLat += pt.lat;
                agg.sumLon += pt.lon;
                agg.sumX += x;
                agg.sumY += y;
                agg.sumScore += pt.score;
                agg.count += 1;
            }

            var nodes = [];
            Object.keys(snappedNodesByKey).forEach(function (k) {
                var n = snappedNodesByKey[k];
                if (!n || n.count < 1) return;
                nodes.push({
                    idx: nodes.length,
                    lat: n.sumLat / n.count,
                    lon: n.sumLon / n.count,
                    x: n.sumX / n.count,
                    y: n.sumY / n.count,
                    score: n.sumScore / n.count,
                    count: n.count
                });
            });
            if (nodes.length < 2) return [];

            var cellSize = connectDistanceM;
            var nodeGrid = {};
            for (var ni = 0; ni < nodes.length; ni++) {
                var nCellKey = toCellKey(nodes[ni].x, nodes[ni].y, cellSize);
                if (!nodeGrid[nCellKey]) nodeGrid[nCellKey] = [];
                nodeGrid[nCellKey].push(ni);
            }

            var nodeAxes = new Array(nodes.length);
            for (var ai = 0; ai < nodes.length; ai++) {
                nodeAxes[ai] = localAxisForNode(ai, nodes, nodeGrid, cellSize);
            }

            var candidateEdges = [];
            var seenPair = {};
            for (var a = 0; a < nodes.length; a++) {
                var nodeA = nodes[a];
                var cellX = Math.floor(nodeA.x / cellSize);
                var cellY = Math.floor(nodeA.y / cellSize);
                for (var dx = -1; dx <= 1; dx++) {
                    for (var dy = -1; dy <= 1; dy++) {
                        var ids = nodeGrid[(cellX + dx) + ':' + (cellY + dy)];
                        if (!ids) continue;
                        for (var ii = 0; ii < ids.length; ii++) {
                            var b = ids[ii];
                            if (b <= a) continue;
                            var pairKey = a + ':' + b;
                            if (seenPair[pairKey]) continue;
                            seenPair[pairKey] = true;
                            var nodeB = nodes[b];
                            var vx = nodeB.x - nodeA.x;
                            var vy = nodeB.y - nodeA.y;
                            var dist = Math.sqrt(vx * vx + vy * vy);
                            if (dist < minDistanceM || dist > connectDistanceM) continue;
                            if (Math.abs(nodeA.score - nodeB.score) > maxScoreDelta) continue;

                            var unit = maybeUnit(vx, vy);
                            if (!unit) continue;
                            var alignA = headingAlignment(unit, nodeAxes[a]);
                            var alignB = headingAlignment(unit, nodeAxes[b]);
                            if (alignA < minAxisAlignment && alignB < minAxisAlignment) continue;

                            var support = 0;
                            if (dist >= supportMinDistanceM) {
                                support = segmentSupportCount(nodeA, nodeB, nodes, nodeGrid, cellSize);
                                if (support < minSupportPoints) continue;
                            }
                            var quality = (support * 2.2) + alignA + alignB - (dist / connectDistanceM);
                            candidateEdges.push({
                                a: a,
                                b: b,
                                dist: dist,
                                support: support,
                                quality: quality
                            });
                        }
                    }
                }
            }

            candidateEdges.sort(function (left, right) {
                if (right.quality !== left.quality) return right.quality - left.quality;
                if (left.dist !== right.dist) return left.dist - right.dist;
                return right.support - left.support;
            });

            var neighbors = new Array(nodes.length);
            var degree = new Array(nodes.length);
            for (var init = 0; init < nodes.length; init++) {
                neighbors[init] = [];
                degree[init] = 0;
            }

            var selectedEdges = [];
            for (var ce = 0; ce < candidateEdges.length; ce++) {
                var edge = candidateEdges[ce];
                var ia = edge.a;
                var ib = edge.b;
                if (degree[ia] >= degreeLimit || degree[ib] >= degreeLimit) continue;

                var okA = true;
                if (neighbors[ia].length > 0) {
                    var existingA = nodes[neighbors[ia][0]];
                    var angleA = turnAngleDeg(existingA, nodes[ia], nodes[ib]);
                    if (angleA < minTurnAngleDeg) okA = false;
                }
                var okB = true;
                if (neighbors[ib].length > 0) {
                    var existingB = nodes[neighbors[ib][0]];
                    var angleB = turnAngleDeg(existingB, nodes[ib], nodes[ia]);
                    if (angleB < minTurnAngleDeg) okB = false;
                }
                if (!okA || !okB) continue;

                selectedEdges.push(edge);
                neighbors[ia].push(ib);
                neighbors[ib].push(ia);
                degree[ia] += 1;
                degree[ib] += 1;
            }

            if (!selectedEdges.length) return [];

            var edgeByKey = {};
            for (var se = 0; se < selectedEdges.length; se++) {
                var e = selectedEdges[se];
                var kLow = Math.min(e.a, e.b);
                var kHigh = Math.max(e.a, e.b);
                edgeByKey[kLow + ':' + kHigh] = e;
            }

            function getEdgeKey(u, v) {
                return (u < v) ? (u + ':' + v) : (v + ':' + u);
            }

            var visitedEdges = {};
            var paths = [];

            function walkPath(startNode, nextNode) {
                var path = [startNode, nextNode];
                visitedEdges[getEdgeKey(startNode, nextNode)] = true;
                var prev = startNode;
                var curr = nextNode;
                var guard = 0;
                while (guard < nodes.length + 4) {
                    guard += 1;
                    var nbrs = neighbors[curr] || [];
                    var candidate = null;
                    for (var ni2 = 0; ni2 < nbrs.length; ni2++) {
                        var maybe = nbrs[ni2];
                        if (maybe === prev) continue;
                        var eKey = getEdgeKey(curr, maybe);
                        if (visitedEdges[eKey]) continue;
                        candidate = maybe;
                        break;
                    }
                    if (candidate === null) break;
                    visitedEdges[getEdgeKey(curr, candidate)] = true;
                    path.push(candidate);
                    prev = curr;
                    curr = candidate;
                }
                return path;
            }

            for (var pn = 0; pn < nodes.length; pn++) {
                if ((neighbors[pn] || []).length !== 1) continue;
                var onlyNbr = neighbors[pn][0];
                var firstKey = getEdgeKey(pn, onlyNbr);
                if (visitedEdges[firstKey]) continue;
                paths.push(walkPath(pn, onlyNbr));
            }

            for (var pz = 0; pz < nodes.length; pz++) {
                var nz = neighbors[pz] || [];
                for (var nzIdx = 0; nzIdx < nz.length; nzIdx++) {
                    var n2 = nz[nzIdx];
                    var eK = getEdgeKey(pz, n2);
                    if (visitedEdges[eK]) continue;
                    paths.push(walkPath(pz, n2));
                }
            }

            var out = [];
            for (var pi = 0; pi < paths.length; pi++) {
                var nodePath = paths[pi];
                if (!nodePath || nodePath.length < 2) continue;
                var latlngs = [];
                var bucketWeights = {};
                for (var pj = 0; pj < nodePath.length; pj++) {
                    var nodeObj = nodes[nodePath[pj]];
                    latlngs.push([nodeObj.lat, nodeObj.lon]);
                    var bucket = String(Math.round(clampScore(nodeObj.score)));
                    bucketWeights[bucket] = (bucketWeights[bucket] || 0) + nodeObj.count;
                }
                var winningBucket = 0;
                var winningWeight = -1;
                Object.keys(bucketWeights).forEach(function (bucketKey) {
                    var bw = bucketWeights[bucketKey];
                    if (bw > winningWeight) {
                        winningWeight = bw;
                        winningBucket = Number(bucketKey);
                    }
                });
                if (!Number.isFinite(winningBucket)) winningBucket = 0;
                out.push({
                    latlngs: latlngs,
                    score: clampScore(winningBucket)
                });
            }
            return out;
        }

        function buildMapillaryRoadBandLayer(geojson) {
            var segments = buildMapillaryRoadBandSegments(geojson, {
                snapMeters: 3.5,
                connectDistanceM: 28,
                minDistanceM: 2.5,
                maxScoreDelta: 1.35,
                axisRadiusM: 32,
                minAxisAlignment: 0.55,
                supportCorridorM: 4.5,
                supportMinDistanceM: 18,
                minSupportPoints: 1,
                degreeLimit: 2,
                minTurnAngleDeg: 60
            });
            var group = L.layerGroup();
            for (var i = 0; i < segments.length; i++) {
                var seg = segments[i];
                var score = clampScore(Number(seg.score));
                if (!Number.isFinite(score)) score = 0;
                var line = L.polyline(seg.latlngs, {
                    pane: 'pane_mapillary_heat_1',
                    color: scoreToColor(score),
                    weight: 9,
                    opacity: 0.72,
                    lineCap: 'round',
                    lineJoin: 'round',
                    smoothFactor: 1.0,
                    interactive: false
                });
                line._mapillaryScore = score;
                group.addLayer(line);
            }
            return group;
        }

        function style_mapillary_colored_dots_1_0(feature) {
            var score = getMapillaryFeatureScore(feature);
            return {
                pane: 'pane_mapillary_colored_dots_1',
                radius: 4.0,
                opacity: 1,
                color: '#ffffff',
                weight: 0.9,
                fill: true,
                fillOpacity: 0.95,
                fillColor: scoreToColor(score),
                interactive: false,
            };
        }

        var layer_mapillary_colored_dots_1 = null;
        var layer_mapillary_heat_1 = null;
        function updateMapillaryOverlayStyles() {
            if (layer_mapillary_colored_dots_1 && layer_mapillary_colored_dots_1.eachLayer) {
                layer_mapillary_colored_dots_1.eachLayer(function (markerLayer) {
                    if (!markerLayer || !markerLayer.feature || !markerLayer.setStyle) return;
                    markerLayer.setStyle(style_mapillary_colored_dots_1_0(markerLayer.feature));
                });
            }
            if (layer_mapillary_heat_1 && layer_mapillary_heat_1.eachLayer) {
                layer_mapillary_heat_1.eachLayer(function (lineLayer) {
                    if (!lineLayer || !lineLayer.setStyle) return;
                    var segmentScore = Number(lineLayer._mapillaryScore);
                    if (!Number.isFinite(segmentScore)) segmentScore = 0;
                    lineLayer.setStyle({ color: scoreToColor(segmentScore) });
                });
            }
        }

        function setMapillaryOverlayMode(modeKey, persist) {
            var nextMode = (modeKey === 'heat') ? 'heat' : 'dots';
            currentMapillaryView = nextMode;
            if (mapillaryViewSelect) {
                mapillaryViewSelect.value = nextMode;
            }
            if (layer_mapillary_colored_dots_1 && map.hasLayer(layer_mapillary_colored_dots_1)) {
                map.removeLayer(layer_mapillary_colored_dots_1);
            }
            if (layer_mapillary_heat_1 && map.hasLayer(layer_mapillary_heat_1)) {
                map.removeLayer(layer_mapillary_heat_1);
            }
            if (showMapillaryData) {
                if (nextMode === 'heat') {
                    if (layer_mapillary_heat_1) map.addLayer(layer_mapillary_heat_1);
                } else {
                    if (layer_mapillary_colored_dots_1) map.addLayer(layer_mapillary_colored_dots_1);
                }
            }
            if (mapillaryDataToggle) {
                mapillaryDataToggle.checked = showMapillaryData;
            }
            if (persist) {
                try {
                    localStorage.setItem('mapillaryOverlayMode', currentMapillaryView);
                } catch (e) {}
            }
        }

        function setMapillaryDataVisibility(visible, persist) {
            showMapillaryData = !!visible;
            if (!showMapillaryData) {
                if (layer_mapillary_colored_dots_1 && map.hasLayer(layer_mapillary_colored_dots_1)) {
                    map.removeLayer(layer_mapillary_colored_dots_1);
                }
                if (layer_mapillary_heat_1 && map.hasLayer(layer_mapillary_heat_1)) {
                    map.removeLayer(layer_mapillary_heat_1);
                }
            } else {
                setMapillaryOverlayMode(currentMapillaryView, false);
            }
            if (mapillaryDataToggle) {
                mapillaryDataToggle.checked = showMapillaryData;
            }
            if (persist) {
                try {
                    localStorage.setItem('showMapillaryData', showMapillaryData ? '1' : '0');
                } catch (e) {}
            }
        }

        function setGroupPhotosVisibility(visible, persist) {
            showGroupPhotos = !!visible;
            if (typeof layer_spt_ai_combined_1 !== 'undefined' && layer_spt_ai_combined_1) {
                if (showGroupPhotos) {
                    if (!map.hasLayer(layer_spt_ai_combined_1)) map.addLayer(layer_spt_ai_combined_1);
                } else if (map.hasLayer(layer_spt_ai_combined_1)) {
                    map.removeLayer(layer_spt_ai_combined_1);
                }
            }
            if (groupPhotosToggle) {
                groupPhotosToggle.checked = showGroupPhotos;
            }
            if (persist) {
                try {
                    localStorage.setItem('showGroupPhotos', showGroupPhotos ? '1' : '0');
                } catch (e) {}
            }
        }

        // Area means from currently shown map dots:
        // Leppävaara: n=31, Kivenlahti: n=13, Mankkaa: n=32 (folder 23 excluded)
        var AREA_AVERAGES = {
            'Leppävaara': 0.22580645161290322,
            'Kivenlahti': -0.6153846153846154,
            'Mankkaa': 0.9375
        };

        function rgbToTextColor(rgb) {
            var m = String(rgb || '').match(/rgb\((\d+),(\d+),(\d+)\)/i);
            if (!m) return '#fff';
            var r = Number(m[1]), g = Number(m[2]), b = Number(m[3]);
            var luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            return luminance > 150 ? '#111' : '#fff';
        }

        function applyAreaAverageButtonStyles() {
            var pairs = [
                ['Leppävaara', gotoLeppaBtn],
                ['Kivenlahti', gotoKivenlahtiBtn],
                ['Mankkaa', gotoMankkaaBtn]
            ];
            pairs.forEach(function(pair) {
                var area = pair[0];
                var btn = pair[1];
                if (!btn) return;
                var avg = Number(AREA_AVERAGES[area]);
                if (!Number.isFinite(avg)) return;
                var bg = scoreToColor(avg);
                var avgTxt = (avg >= 0 ? '+' : '') + avg.toFixed(2);
                btn.style.background = bg;
                btn.style.color = rgbToTextColor(bg);
                btn.style.borderColor = 'rgba(255,255,255,0.45)';
                btn.textContent = area + ' ' + avgTxt;
                btn.title = area + ' average AI_overall (all photos): ' + avgTxt;
            });
        }

        function style_spt_ai_combined_1_0(feature) {
            var raw = feature && feature.properties ? feature.properties['AI_overall'] : null;
            var score = Number(raw);
            if (!Number.isFinite(score)) {
                score = 0;
            }
            var strokeColor = 'rgba(35,35,35,1.0)';
            var strokeWeight = 1.4;
            var strokeDashArray = '';
            var markerRadius = 6.0;
            return {
                pane: 'pane_spt_ai_combined_1',
                radius: markerRadius,
                opacity: 1,
                color: strokeColor,
                dashArray: strokeDashArray,
                lineCap: 'round',
                lineJoin: 'round',
                weight: strokeWeight,
                fill: true,
                fillOpacity: 1,
                fillColor: scoreToColor(score),
                interactive: true,
            }
        }
        map.createPane('pane_spt_ai_combined_1');
        map.getPane('pane_spt_ai_combined_1').style.zIndex = 401;
        map.getPane('pane_spt_ai_combined_1').style['mix-blend-mode'] = 'normal';
        var layer_spt_ai_combined_1 = new L.geoJson(json_spt_ai_combined_1, {
            attribution: '',
            interactive: true,
            dataVar: 'json_spt_ai_combined_1',
            layerName: 'layer_spt_ai_combined_1',
            pane: 'pane_spt_ai_combined_1',
            onEachFeature: pop_leppavaara_photo_index_ai_1,
            pointToLayer: function (feature, latlng) {
                var context = {
                    feature: feature,
                    variables: {}
                };
                return L.circleMarker(latlng, style_spt_ai_combined_1_0(feature));
            },
        });
        bounds_group.addLayer(layer_spt_ai_combined_1);
        map.addLayer(layer_spt_ai_combined_1);

        map.createPane('pane_mapillary_heat_1');
        map.getPane('pane_mapillary_heat_1').style.zIndex = 402;
        map.getPane('pane_mapillary_heat_1').style['mix-blend-mode'] = 'normal';

        map.createPane('pane_mapillary_colored_dots_1');
        map.getPane('pane_mapillary_colored_dots_1').style.zIndex = 403;
        map.getPane('pane_mapillary_colored_dots_1').style['mix-blend-mode'] = 'normal';

        layer_mapillary_colored_dots_1 = new L.geoJson(json_mapillary_downloaded_points, {
            attribution: '',
            interactive: false,
            dataVar: 'json_mapillary_downloaded_points',
            layerName: 'layer_mapillary_colored_dots_1',
            pane: 'pane_mapillary_colored_dots_1',
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, style_mapillary_colored_dots_1_0(feature));
            },
        });

        layer_mapillary_heat_1 = buildMapillaryRoadBandLayer(json_mapillary_downloaded_points);

        if (scorePaletteSlider) {
            scorePaletteSlider.addEventListener('input', function () {
                setScorePaletteMode(paletteIndexToMode(scorePaletteSlider.value), true);
            });
            scorePaletteSlider.addEventListener('change', function () {
                setScorePaletteMode(paletteIndexToMode(scorePaletteSlider.value), true);
            });
        }
        if (paletteSliderTicks && paletteSliderTicks.length) {
            paletteSliderTicks.forEach(function (tick) {
                tick.addEventListener('click', function () {
                    var modeKey = tick.getAttribute('data-mode');
                    setScorePaletteMode(modeKey, true);
                });
            });
        }
        if (paletteSliderToggleBtn) {
            paletteSliderToggleBtn.addEventListener('click', function () {
                setPaletteSliderCollapsed(!paletteSliderCollapsed, true);
            });
        }
        if (basemapSelect) {
            basemapSelect.addEventListener('change', function () {
                setBasemapMode(basemapSelect.value, true);
            });
        }
        if (mapillaryViewSelect) {
            mapillaryViewSelect.addEventListener('change', function () {
                setMapillaryOverlayMode(mapillaryViewSelect.value, true);
            });
        }
        if (groupPhotosToggle) {
            groupPhotosToggle.checked = showGroupPhotos;
            groupPhotosToggle.addEventListener('change', function () {
                setGroupPhotosVisibility(groupPhotosToggle.checked, true);
            });
        }
        if (mapillaryDataToggle) {
            mapillaryDataToggle.checked = showMapillaryData;
            mapillaryDataToggle.addEventListener('change', function () {
                setMapillaryDataVisibility(mapillaryDataToggle.checked, true);
            });
        }
        if (shadowWeekToggleBtn) {
            shadowWeekToggleBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                setShadowWeekPanelOpen(!shadowWeekPanelOpen);
            });
        }
        if (shadowWeekPanel) {
            shadowWeekPanel.addEventListener('click', function (e) {
                e.stopPropagation();
            });
        }
        if (shadowWeekSlider) {
            shadowWeekSlider.value = String(shadowClockWeek);
            shadowWeekSlider.addEventListener('input', function () {
                shadowClockWeek = Number(shadowWeekSlider.value);
                if (shadowClockLive) {
                    setShadowClockLiveMode(false, true);
                } else {
                    applyShadowClockTime(true);
                }
            });
            shadowWeekSlider.addEventListener('change', function () {
                shadowClockWeek = Number(shadowWeekSlider.value);
                applyShadowClockTime(true);
            });
        }
        document.addEventListener('click', function (e) {
            if (!shadowWeekPanelOpen) return;
            var target = e.target;
            if (shadowClockControl && target && shadowClockControl.contains(target)) return;
            setShadowWeekPanelOpen(false);
        });
        if (shadowTimeSlider) {
            shadowTimeSlider.value = String(shadowClockMinutes);
            shadowTimeSlider.addEventListener('input', function () {
                shadowClockMinutes = Number(shadowTimeSlider.value);
                if (shadowClockLive) {
                    setShadowClockLiveMode(false, true);
                } else {
                    applyShadowClockTime(true);
                }
            });
            shadowTimeSlider.addEventListener('change', function () {
                shadowClockMinutes = Number(shadowTimeSlider.value);
                applyShadowClockTime(true);
            });
        }
        if (shadowNowBtn) {
            shadowNowBtn.addEventListener('click', function () {
                syncShadowDateFromNow();
                if (shadowClockLive) {
                    setShadowClockLiveMode(true, true);
                } else {
                    applyShadowClockTime(true);
                }
            });
        }
        if (shadowLiveToggle) {
            shadowLiveToggle.checked = shadowClockLive;
            shadowLiveToggle.addEventListener('change', function () {
                setShadowClockLiveMode(shadowLiveToggle.checked, true);
            });
        }
        setShadowWeekPanelOpen(false);
        setBasemapMode(currentBasemapMode, false);
        setPaletteSliderCollapsed(paletteSliderCollapsed, false);
        setScorePaletteMode(currentScorePaletteMode, false);
        setMapillaryOverlayMode(currentMapillaryView, false);
        setGroupPhotosVisibility(showGroupPhotos, false);
        setMapillaryDataVisibility(showMapillaryData, false);
        if (shadowClockLive) {
            setShadowClockLiveMode(true, false);
        } else {
            setShadowClockLiveMode(false, false);
        }
        map.on('unload', function () {
            stopShadowClockTimer();
        });

                setBounds();
        </script>
    </body>
</html>
